// 2. Huffman Tree Operations (HuffmanTree.java)// ● Manages the Huffman tree dynamically during encoding/decoding.// ● Key operations://      ○ Inserting new symbols and handling the NYT (Not Yet Transmitted) node.//      ○ Rebalancing/adjusting the nodes counts based on symbols frequency.//      ○ Swapping nodes to maintain Huffman tree properties./*basic root tree will have it and right and left childrensthen we are to add new symbol , so we have to search for nyt.split nyt into two nodes adding the new symbol and increasing the counter.go to parent and increment 1;check for swap condition {    the swap conditions and using the traversal so the first accepted node is the most sutable.    then swap; take note that left or ride child can be identefied by odd or even node number.    } */package src;import java.util.Objects;public class HuffmanTree {    Node root;    private Node nyt; // Keep track of the NYT node    public HuffmanTree(){        root = new Node(0, 100, null);    }    public void insertSymbol(String symbol){        if (getNode(root, symbol) != null){            incrementSymbolFreq(symbol);        } else {            addNewNode(symbol);        }    }    public void addNewNode(String symbol){// new symbol is inserted to tree        if (root.getFreq()==0){            Node left= new Node(0,98,"NYT");            Node right = new Node(1,99,symbol);            left.setParent(root);            right.setParent(root);            root.setLeft(left);            root.setRight(right);            root.incrementFreq();            root.setSymbol(null);            nyt = left;        }        else {            Node parent = nyt; // Use tracked NYT node instead of searching            int parentNumber = parent.NNumber();            int leftNumber = parentNumber - 2;            int rightNumber = parentNumber - 1;            Node left = new Node(0, leftNumber, "NYT");            Node right = new Node(1, rightNumber, symbol);            left.setParent(parent);            right.setParent(parent);            parent.setLeft(left);            parent.setRight(right);            parent.incrementFreq();            parent.setSymbol(null);            nyt = left; // Update NYT reference            while (parent != root) {                parent = parent.getParent();                Node swapNode = getSwappable(root, parent);                if (swapNode != null) {                    swap(swapNode, parent);                }                parent.incrementFreq();            }        }    }    public void incrementSymbolFreq(String symbol){        Node node = getNode(root, symbol);        while (node != root){            Node swapNode = getSwappable(root, node);            if (swapNode != null){                swap(swapNode, node);            }            node.incrementFreq();            node = node.getParent();        }        node.incrementFreq();    }    public Node getNode(Node root, String searchSymbol){        if (root == null) return null;        if (Objects.equals(root.getSymbol(), searchSymbol)) return root;        Node leftResult = getNode(root.getLeft(), searchSymbol);        if (leftResult != null) return leftResult;        return getNode(root.getRight(), searchSymbol);    }    public Node getSwappable(Node root, Node myNode){        if (root == null) return null;        if (swappable(myNode, root)) return root;        Node leftResult = getSwappable(root.getLeft(), myNode);        if (leftResult != null) return leftResult;        return getSwappable(root.getRight(), myNode);    }    public boolean swappable(Node myNode, Node node){        return myNode.NNumber() < node.NNumber() && myNode.getFreq() >= node.getFreq() && myNode.getParent() != node && myNode != node;    }    public void swap(Node myNode, Node node){        Node myParent = myNode.getParent();        Node nodeParent = node.getParent();        if (myParent.getLeft() == myNode) myParent.setLeft(node);        else myParent.setRight(node);        if (nodeParent.getLeft() == node) nodeParent.setLeft(myNode);        else nodeParent.setRight(myNode);        myNode.setParent(nodeParent);        node.setParent(myParent);        int temp = myNode.NNumber();        myNode.setNNumber(node.NNumber());        node.setNNumber(temp);    }    public void printTree(Node root){        if (root == null) return;        System.out.print(root.getSymbol() + " ");        printTree(root.getLeft());        printTree(root.getRight());    }    public Node getRoot(){        return root;    }    public static void main(String[] args) {        HuffmanTree tree = new HuffmanTree();        tree.insertSymbol("A");        tree.insertSymbol("B");        tree.insertSymbol("C");        tree.insertSymbol("A"); // Increment frequency of 'A'        tree.printTree(tree.root);    }}